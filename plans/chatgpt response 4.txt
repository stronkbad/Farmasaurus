Below is a **complete, end-to-end MVP plan** to build a **browser-based isometric MMO prototype** with the *feel* of **Ultima Online**, **RuneScape**, and **Ragnarok Online**.

This plan is intentionally **minimal**, **linear**, and **non-branching**.
If you follow it in order, you will end with a playable, stable MVP—not a tech demo.

---

# MVP DEFINITION (LOCK THIS FIRST)

Your MVP is **done** when all of the following are true:

* One player can move around a large map
* Movement feels stable (no rubberbanding)
* Server is authoritative
* Client interpolates smoothly
* Water / blocked tiles are respected
* Latency (even artificial) does not break movement

**No combat. No skills. No NPCs. No persistence.**

---

# TECHNOLOGY BASELINE (DO NOT EXPAND)

## Client

* PIXI.js
* WebSocket
* Fixed timestep render loop
* Single player entity

## Server

* Node.js
* WebSocket
* Fixed tick loop (10–20 Hz)
* In-memory world state

---

# PHASE 0 — WORLD & AUTHORITY (FOUNDATION)

### Goal

Define the **rules of reality** before visuals.

### Tasks

1. Define a logical grid

   ```ts
   type Tile = 0 | 1; // 0 = walkable, 1 = blocked
   type TilePos = { x: number; y: number };
   ```

2. Generate a small world

   * Example: 128 × 128 tiles
   * Some blocked (water, cliffs)

3. Server owns:

   * Player tile position
   * World collision rules

### Exit criteria

* Server can answer: “Is tile (x,y) walkable?”

---

# PHASE 1 — MOVEMENT VALIDATION (CORE LOGIC)

### Goal

Ensure movement is **deterministic and discrete**.

### Tasks

1. Implement movement validator (server)

   ```ts
   canMove(from: TilePos, dir): TilePos | null
   ```

2. Only allow:

   * One tile per step
   * Cardinal + diagonal directions (8-way)

3. Reject invalid steps (blocked, out of bounds)

### Exit criteria

* Server never updates player position without validation
* No continuous movement exists on server

---

# PHASE 2 — SERVER TICK LOOP

### Goal

Create RuneScape-style **authoritative ticks**.

### Tasks

1. Fixed tick loop (example: 15 Hz)

2. On each tick:

   * Process queued move intents
   * Apply validator
   * Update tile positions

3. Server never cares about:

   * Frame rate
   * Rendering
   * Mouse position

### Exit criteria

* Movement only advances on ticks
* Tick rate change does not break logic

---

# PHASE 3 — CLIENT INPUT (INTENT, NOT MOTION)

### Goal

Send **intent**, not position.

### Tasks

1. Right-click movement

   * On click: compute direction
   * Latch direction + run mode
   * Do NOT recompute every frame

2. Send:

   ```ts
   { seq, direction, run }
   ```

3. Only send:

   * Once per step
   * Never per frame

### Exit criteria

* Input rate ≠ simulation rate
* Direction does not oscillate

---

# PHASE 4 — CLIENT PREDICTION (NO WAITING)

### Goal

Hide latency without lying.

### Tasks

1. On sending move intent:

   * Immediately animate toward target tile

2. Track:

   * Current logical tile (client-side)
   * Target tile
   * Render position (float)

3. Assume success unless told otherwise

### Exit criteria

* Movement starts instantly on input
* No waiting for server reply

---

# PHASE 5 — SERVER ACK & CORRECTION

### Goal

Ensure authority without snapping.

### Tasks

1. Server replies with:

   ```ts
   { ackSeq, tileX, tileY, accepted }
   ```

2. Client behavior:

   * If accepted → continue
   * If rejected → cancel queued steps
   * Ease render position toward authoritative tile

3. Teleport only if error > threshold

### Exit criteria

* No visual snapping
* Rejections feel like “bump”, not rewind

---

# PHASE 6 — INTERPOLATION & FEEL

### Goal

Make it feel modern without breaking rules.

### Tasks

1. Render position chases authoritative position

   ```ts
   pos += (target - pos) * alpha
   ```

2. Camera follows with lag

3. Animate sprites independently of logic

### Exit criteria

* Simulation unchanged if rendering is disabled
* Increasing FPS only improves smoothness

---

# PHASE 7 — LARGE MAP ILLUSION

### Goal

Prove scalability early.

### Tasks

1. Expand logical grid (e.g. 1024 × 1024)
2. Only render visible chunk
3. Server still validates tiles the same way

### Exit criteria

* World feels “large”
* No logic changes required

---

# MVP STOP POINT (IMPORTANT)

At this point:

* Movement is solid
* Architecture is correct
* Everything else is optional

**Stop here. Commit. Tag the repo.**

---

# WHAT YOU DELIBERATELY DO NOT BUILD YET

* Combat
* Stats
* Pathfinding
* NPC AI
* Persistence
* Login systems

Every one of those depends on movement being correct.

---

# NORTH STAR INVARIANT (DO NOT BREAK)

> **The server never has to pull the player backward.**

If that invariant holds:

* The game will feel good
* Scaling will be possible
* Content can be added safely

---

## Final note (important)

This MVP is **boring to implement** and **hard to get right**.
That is why most indie MMOs fail *before* content.

If you finish this MVP cleanly, you will already be ahead of 90% of attempts in this genre.
